<p align="center">
  <a href="https://github.com/txt/guru26spr/blob/main/README.md"><img 
     src="https://img.shields.io/badge/Home-%23ff5733?style=flat-square&logo=home&logoColor=white" /></a>
  <a href="https://github.com/txt/guru26spr/blob/main/docs/lect/syllabus.md"><img 
      src="https://img.shields.io/badge/Syllabus-%230055ff?style=flat-square&logo=openai&logoColor=white" /></a>
  <a href="https://docs.google.com/spreadsheets/d/1xZfIwkmu6hTJjXico1zIzklt1Tl9-L9j9uHrix9KToU/edit?usp=sharing"><img
      src="https://img.shields.io/badge/Teams-%23ffd700?style=flat-square&logo=users&logoColor=white" /></a>
  <a href="https://moodle-courses2527.wolfware.ncsu.edu/course/view.php?id=8119"><img 
      src="https://img.shields.io/badge/Moodle-%23dc143c?style=flat-square&logo=moodle&logoColor=white" /></a>
  <a href="https://discord.gg/vCCXMfzQ"><img 
      src="https://img.shields.io/badge/Chat-%23008080?style=flat-square&logo=discord&logoColor=white" /></a>
  <a href="https://github.com/txt/guru26spr/blob/main/LICENSE.md"><img 
      src="https://img.shields.io/badge/©%20timm%202026-%234b4b4b?style=flat-square&logoColor=white" /></a></p>
<h1 align="center">:cyclone: CSC491/591: How to be a SE Guru <br>NC State, Spring '26</h1>
<img src="https://raw.githubusercontent.com/txt/guru26spr/refs/heads/main/etc/img/banenr.png"> 


## Review

### Little Languages (Domain-Specific Conventions)

**Philosophy: Open/Closed Principle for Specification**

Little languages are **tiny specification tools** that allow extension without
modification. They embody the **open/closed principle**: the code is **closed
for modification** (the interpreter stays the same) but **open for extension**
(users add new meanings via simple syntax).

Benefits:
- **Declarative over imperative**: Specify *what*, not *how*
- **Self-documenting**: The specification IS the documentation
- **Zero boilerplate**: No XML, no config classes, no validation frameworks
- **User-friendly**: Non-programmers can understand and modify
- **Composable**: Small languages combine naturally

---

#### Example 1: Column Header Language → `Col()` factory

**The Language:**
```
Age       → NUM (uppercase = numeric)
name      → SYM (lowercase = symbolic)
Weight!   → NUM in cols.y (! = goal/dependent)
ID_X      → ignored (X = skip)
income    → in cols.x (default = independent variable)
```

**The Interpreter (3 lines):**
```python
def Col(n=0, s=""):
    return (Num if s[0].isupper() else Sym)(n, s)

# In Cols():
x = [c for c in all if not re.search(r"[!X]$", c.txt)]  # independents
y = [c for c in all if re.search(r"!$", c.txt)]         # dependents
```

**Why this is useful:**
- **Open**: Users add columns by typing headers like "Salary!" or "age"
- **Closed**: `Col()` code never changes
- **Self-documenting**: CSV header tells you everything about the data structure
- **No schema files**: The data carries its own metadata

---

#### Example 2: Docstring → Config (the `__doc__` → `the` pattern)

**The Language (embedded in help text):**
```python
"""
OPTIONS
-h          Show help.
-k k=1      Bayes low frequency hack for symbolic attributes.
-m m=2      Bayes low frequency hack for class priors.
-w wait=5   Start classifying after seeing "some" rows
"""
```

**The Interpreter (1 line):**
```python
the = Obj(**{k:cast(v) for k,v in re.findall(r"(\S+)=(\S+)", __doc__)})
```

**How it works:**
1. Regex `r"(\S+)=(\S+)"` finds all `key=value` patterns in docstring
2. `cast(v)` converts strings: `"1"→1`, `"5"→5`
3. Dict comprehension builds `{"k": 1, "m": 2, "wait": 5}`
4. `Obj(**dict)` unpacks to keyword args, creating `the.k`, `the.m`, `the.wait`

**Result:**
```python
the.k     # 1
the.m     # 2
the.wait  # 5
```

**Why this is useful:**
- **Open**: Add new options by typing `option=default` anywhere in docstring
- **Closed**: Config parsing code never changes
- **Single source of truth**: Help text IS the config specification
- **No duplication**: Don't write help, then separately parse args, then validate
- **Type inference**: `cast()` handles int/float/string automatically
- **Override via CLI**: `python nb.py -k 2` overrides defaults

**The `Obj` trick:**
```python
class Obj(dict):
    __getattr__, __setattr__, __repr__ = dict.__getitem__, dict.__setitem__, o
```
- Inherit from `dict` for `**kwargs` unpacking
- Override `__getattr__` → dot notation: `the.k` instead of `the["k"]`
- Override `__repr__` → pretty printing via custom `o()` function
- 1 line replaces 20 lines of `argparse` boilerplate

---

#### Example 3: CLI Function Dispatch (--flag → eg_flag())

**The Language:**
```bash
python3 nb.py --nb file.csv
python3 nb.py --the
python3 nb.py --sym
```

**The Interpreter:**
```python
if __name__ == "__main__":
    for j, s in enumerate(sys.argv):
        if f := vars().get(f"eg{s.replace('!', '_')}"):
            f(sys.argv[j+1] if j+1 < len(sys.argv) else None)
```

**How it works:**
1. `--nb` → string replacement → `"--nb".replace("!", "_")` → `"__nb"`
2. String interpolation → `f"eg__nb"`
3. `vars()` returns dict of current scope (all `eg_*` functions)
4. `.get("eg__nb")` retrieves function object
5. Call it with next arg: `f(sys.argv[j+1])`

**Function definitions:**
```python
def eg__the(_):  print(o(the))
def eg__nb(f):   [print(n,*x) for x,n in nb(csv(f)).has.items()]
def eg__sym(_):  print(add(add(add(Sym(),"a"),"a"),"b"))
```

**Why this is useful:**
- **Open**: Add `def eg__newtest():` and `--newtest` automatically works
- **Closed**: Dispatch mechanism never changes
- **Convention over configuration**: Naming convention IS the API
- **No framework**: No test runner, no decorators, just functions

---

#### Example 4: Type Hints as Single-Letter Mini-Language

**The Language:**
```python
# Type Hints (single letter)
# i:instance(Obj)  t:target(dict)  s:string  n:number
# r:row(list)      c:col(Obj)      v:value   f:file/filename
# d:delta/data     k:class/key     b4:before(prior)
```

**Usage in signatures:**
```python
def like(i, v, prior=0):     # i=instance, v=value
def likes(i, r, nall, nh):    # i=instance, r=row, n*=numbers
def add(i, v):                # polymorphic: i could be Data/Sym/Num
```

**Why this is useful:**
- **Cognitive load**: `like(col, val, p)` vs `like(c, v, p)` - same info, less
  noise
- **Consistency**: Same letter always means same concept across codebase
- **Self-documenting**: Trained readers parse faster than
  `column_instance_object`
- **Open**: Add new conventions (`p:probability`) without changing code

---

#### Example 5: Gawk Field Separator Mini-Language

**The Language:**
```awk
BEGIN { FS="," }           # comma-separated values
BEGIN { FS="[ \t]+" }      # whitespace (space or tab, one or more)
BEGIN { RS="" }            # paragraph mode (blank line = record separator)
BEGIN { FS=","; OFS="|" }  # input comma, output pipe
```

**Why this is useful:**
- **Open**: Any regex becomes a valid separator
- **Closed**: Awk's field splitting code never changes
- **Declarative**: State the pattern, awk does the parsing
- **Composable**: `FS` + `RS` + `OFS` combine to handle complex formats

---

**Key Insight:** Little languages convert **data into code**. The column header
"Age!" doesn't just label a column—it *programs* the system to treat it as a
numeric goal variable. The docstring doesn't just document—it *configures* the
runtime. This is the essence of **open/closed**: the interpreter is closed, but
the specification language opens infinite extensions.

---

### First-Class Functions / Higher-Order Functions

**Python (nb.py):**
1. **Lambda in max()** - `fn = lambda cat: likes(klasses[cat], row, n-1, nh);
   max(klasses, key=fn)`
2. **Functions as dict values** - `vars().get(f"eg{s.replace('!', '_')}")`
   returning function objects
3. **List comprehension with function** - `[cast(x) for x in s.split(",")]`
   passing cast as iterator

**Lua (lib.lua/nb.lua):**
1. **Functions as return values** - `iter()` returns closure function
2. **Functions as table values** - `eg["--nb"] = function(f) nb(csv(f)) end`
3. **Higher-order sum/kap/sel** - `sum(t,f)`, `kap(t,f)`, `sel(t,f)` take
   functions as parameters
4. **Nested function definitions** - `classify()`, `train()`, `seen()` defined
   inside `nb()`
5. **Function composition** - `l.sum(i.cols.x, function(c) ... end)`

**Gawk (from lecture notes):**
1. **No first-class functions** - Gawk doesn't support functions as values
2. **Workaround: function names as strings** - Not shown in examples but
   possible via indirect calls

---

### Polymorphism

**Polymorphism via Duck Typing (Python):**
- `add(i, v)` works on Data, Sym, or Num based on content inspection
- `like(i, v, prior)` - Different implementations for Num vs Sym via duck typing
- Factory pattern: `Col(n,s)` returns Num or Sym based on string case

**Polymorphism via Metatables (Lua):**
- `SYM.add`, `NUM.add`, `DATA.add` as method dispatch
- Method call syntax: `i:add(v)` sugar for `SYM.add(i, v)` or `NUM.add(i, v)`
- `__index` metamethod for method lookup and lazy computation
- Example: Computing age on demand, memoization pattern

**Polymorphism via Dunder Methods (Python):**
- `__repr__`, `__str__`, `__getattr__`, `__setattr__` as method protocol
- Many classes respond to same polymorphic pattern
- Example: `Obj` class overriding dict methods for dot notation

**Central Controller Pattern:**
- Game controller sends `move()`, `draw()`, `refresh()` to diverse objects
- Each object (rock, tree, player) responds differently to same message
- Add new visual widgets without modifying central controller
- Modify periphery without touching center

---

### Hash Table Implementation Details

**Lua tables:**
- **Numeric keys (consecutive from 1)**: Array behavior
  - `#t` returns length
  - `ipairs(t)` iterates in index order
- **Symbolic keys**: Dictionary/hash table behavior
  - `#t` returns 0 (even if 10 items present)
  - `pairs(t)` iteration order is undefined
- **Negative indices**: Tables can have negative numeric indices
- **Hash collision handling**: Internal tricks make iteration order unspecified

**Python dictionaries:**
- Pre-3.6: Iteration order undefined (like Lua hash tables)
- Python 3.6/3.7: Stabilized insertion order preservation
- Dict order now guaranteed part of language specification

---

### Python Concepts (nb.py)

1. **Obj class pattern** - Using dict with custom __getattr__/__setattr__ for
   dot notation
2. **Config extraction from docstring** - Parsing parameters using regex on
   __doc__
3. **Function dispatch pattern** - Using vars() and dynamic function lookup for
   CLI
4. **Walrus operator** - Assignment expressions in conditionals (`:=`)
5. **Match/case statements** - Python 3.10+ pattern matching in o() function
6. **Duck typing polymorphism** - `add(i, v)` works on Data, Sym, or Num based
   on content
7. **Factory pattern** - `Col(n,s)` returns Num or Sym based on string case
8. **Polymorphic like()** - Different implementations for Num vs Sym via duck
   typing

---

### Lua Concepts (lib.lua/nb.lua)

1. **Iterator abstraction** - Converting both tables and functions to unified
   iterator interface
2. **Metatable pattern** - Using `__index` and `setmetatable` for OOP
3. **Metatable _is field** - Type identification string in metatables
4. **Local function scoping** - One-pass compilation, local keyword behavior
5. **Multiple return values** - `more,state,key = pairs(t)`
6. **Table constructor syntax** - `{at=n or 0, txt=s or ""}`
7. **String pattern matching** - `s:match"^%s*(.−)%s*$"` for trimming
8. **Function parameters with locals** - `function sum(t,f, n)` where n is
   local after space
9. **Negative array indexing** - Using `#t>0` to distinguish arrays from
   dictionaries
10. **gmatch for parsing** - `help:gmatch("(%S+)=(%S+)")`
11. **Metatable polymorphism** - `SYM.add`, `NUM.add`, `DATA.add` as method
    dispatch
12. **Method call syntax** - `i:add(v)` sugar for `add(i, v)`

---

### Gawk Concepts (from lecture notes)

1. **Pattern-action structure** - `pattern { action }`
2. **Field variables** - `$0, $1, $NF`
3. **Built-in variables** - `NR, NF, FS, RS, OFS`
4. **BEGIN/END blocks**
5. **Associative arrays** - Hash maps with automatic initialization
6. **Multi-dimensional array keys** - `Data[class, col, val]++` (uses SUBSEP
   internally)
7. **next statement** - Skip to next record
8. **SUBSEP** - Internal separator for multi-key arrays
9. **Command-line variables** - `gawk -v Seed=$RANDOM`
10. **Streaming/incremental processing**
11. **No variable declarations** - Variables materialize on use
12. **Arrays are references** - Pass by reference in functions

---

### Data Structure Concepts

**Type hierarchy:**
- **THING** = int | float | str | "?"
- **ROW** = [THING]
- **ROWS** = [ROW]
- **COL** = NUM | SYM (polymorphic types)
- **COLS** = {names, all, x, y} where all/x/y are [COL]
- **DATA** = {rows: ROWS, cols: COLS}

**Polymorphic operations:**
- `add(COL, v)` - Different for NUM (Welford) vs SYM (counting)
- `like(COL, v, prior)` - Different for NUM (Gaussian) vs SYM (frequency)
- Factory dispatch via `Col(n,s)` returning NUM or SYM based on case

---

### Bayes Classifier Concepts

**Mathematical foundation:**
- **Bayes Theorem**: P(H|E) = P(E|H) × P(H) / P(E)
- **Naive assumption**: Features are independent given the class
- **Log probabilities**: To avoid underflow
- **Laplace smoothing**: (count + k) / (total + k×attributes)

**Bayes processes NUM and SYM differently:**

**For SYM (symbolic/categorical features):**
- **Storage**: Count frequencies in hash `has[value] = count`
- **Likelihood**: `P(value|class) = (freq[value] + k×prior) / (n + k)`
- **Example**: For color="red" in class="yes", count how often "red" appears
  with "yes"

**For NUM (numeric features):**
- **Storage**: Welford's algorithm tracks `mu` (mean), `m2` (sum of squared
  deviations), `sd` (std dev)
- **Likelihood**: Gaussian PDF: `(1/√(2π×var)) × exp(-((v-μ)²)/(2×var))`
- **Example**: For temperature=72°, calculate probability density using normal
  distribution
- **Variance**: `var = sd² + 1/BIG` (add small constant to avoid division by
  zero)
- **Incremental statistics**: Welford's algorithm avoids two-pass computation

**Key difference**: SYM uses discrete counting, NUM uses continuous probability
density functions

**Implementation patterns:**
- **Incremental learning**: Train after each classification
- **Burn-in period**: Wait N rows before classifying
- **Prior probability**: (class_count + m) / (total + m×num_classes)
- **Streaming CSV processing**: Iterator pattern with `csv()` generator

---

## Questions

### Q1. Little Languages
a) What is the "open/closed principle" for little languages? (2 min)

b) You have a CSV with headers: `Name,age,Salary!,ID_X,Weight`. Which columns
end up in `cols.x`, which in `cols.y`, and which are ignored? Write the 3-line
`Col()` function that implements this language. (4 min)

---

### Q2. Docstring Config Pattern
a) What does this line do: `the = Obj(**{k:cast(v) for k,v in
re.findall(r"(\S+)=(\S+)", __doc__)})` (2 min)

b) Given this docstring fragment:
```python
"""
-k k=1     Laplace smoothing
-m m=2     Prior weight
-w wait=5  Burn-in rows
"""
```
What will `the.k`, `the.m`, and `the.wait` equal after parsing? Write the
`cast()` function that converts `"1"` to `1` and `"hello"` to `"hello"`. (4
min)

---

### Q3. CLI Dispatch Pattern
a) In `vars().get(f"eg{s.replace('!', '_')}")`, what does `vars()` return? (2
min)

b) You want `python nb.py --stats file.csv` to call `eg__stats(file.csv)`. Write
the dispatch loop that makes this work. Handle the case where the function
needs an argument. (4 min)

---

### Q4. Polymorphism via Duck Typing
a) What is duck typing? How does `add(i, v)` work polymorphically in Python
without explicit type checks? (2 min)

b) Write a polymorphic `add(i, v)` function that:
- If `i` has `"rows"`, treat it as Data and append to `i.rows`
- If `i` has `"mu"`, treat it as Num and update Welford stats
- Otherwise treat it as Sym and increment `i.has[v]`
Show the code. (4 min)

---

### Q5. Lua Metatables
a) What does `setmetatable(t, {__index = mt})` do? (2 min)

b) Write Lua code that creates a `NUM` metatable with an `add` method, then
creates an instance `n = {mu=0, n=0}` that uses this metatable. Show how
calling `n:add(10)` dispatches to `NUM.add`. (4 min)

---

### Q6. Hash Tables and Iteration
a) In Lua, what does `#t` return for a table with numeric keys `{1,2,3}` vs
symbolic keys `{a=1, b=2, c=3}`? (2 min)

b) You have `t = {name="Alice", age=30, 1, 2, 3}`. Which iterator (`ipairs` or
`pairs`) gives you `1,2,3`? Which gives you all five items? What order are
symbolic keys returned? (4 min)

---

### Q7. First-Class Functions
a) What does it mean for functions to be "first-class"? Give two examples from
Python or Lua. (2 min)

b) Write a Lua function `make_adder(n)` that returns a function. The returned
function should add `n` to its argument. Demonstrate: `add5 = make_adder(5);
print(add5(10))` should print 15. What has the returned function "closed over"?
(4 min)

---

### Q8. Naive Bayes - SYM vs NUM
a) How does Naive Bayes calculate likelihood differently for symbolic vs numeric
features? (2 min)

b) For a SYM column tracking color="red" in class="yes":
- After seeing "red" 3 times in "yes" class (n=10 total "yes" instances)
- With Laplace smoothing k=1, 3 possible colors
- Calculate `P(red|yes)` using the formula `(freq + k×prior) / (n + k)`
- Assume prior=0.5
Then explain why we use Gaussian PDF for numeric features instead. (4 min)

---

### Q9. Welford's Algorithm
a) What problem does Welford's algorithm solve? (2 min)

b) Given Welford's update formulas:
```python
d = v - i.mu
i.mu = i.mu + d/i.n
i.m2 = i.m2 + d*(v - i.mu)
```
Trace the values of `mu` and `m2` after adding [10, 20, 30] to an empty Num
object (starting `mu=0, m2=0, n=0`). Show your work. (4 min)

---

### Q10. Gawk Associative Arrays
a) In gawk, what does `Freq[class, col, val]++` do? What is SUBSEP? (2 min)

b) Write gawk code that counts how many times each word appears in each line.
Store in `Count[NR, word]`. At END, print line 3's word counts. Use FS to split
on whitespace. (4 min)

---

### Q11. Open/Closed via Class Variables
a) How does a class variable allow "open for extension, closed for modification"?
(2 min)

b) Write a parent class `Thing` with `DECIMALS=2` and `__repr__` that rounds
floats in `self.__dict__` to `self.DECIMALS` places. Then write a subclass
`Money(Thing)` that sets `DECIMALS=2` and a subclass `Precision(Thing)` that
sets `DECIMALS=5`. Show that you never modify `Thing.__repr__`. (4 min)

---

### Q12. Incremental Naive Bayes
a) What is "incremental learning"? What is the "burn-in period"? (2 min)

b) Given this gawk pattern:
```awk
NR <= 10  { train(); next }
          { predicted = classify(); print predicted, actual; train() }
```
Explain what happens on line 5, line 10, and line 15. Why does `train()` appear
in both branches? (4 min)
